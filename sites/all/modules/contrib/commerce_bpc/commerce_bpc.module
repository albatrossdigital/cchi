<?php
/**
 * @file
 * This module will use a form input page to allow users to create related
 * products quickly and easily.
 * It will also create new functions that can be used by other modules for
 * bulk product creation.
 */

/**
 * Implements hook_help().
 */
function commerce_bpc_help($path, $arg) {
  switch ($path) {
    case 'admin/help#commerce_bpc':
      return t('This module helps you create groups of related products quickly and easily.
        To use it, you must have at least one Product Type that has one or more fields attached to it.
        If you wish to attach the products all at once to a Display Node as part of the Bulk Creation process,
        you must first have created a Display Node Type that has a commerce_product_reference field which can accept multiple products.');
  }
}

/**
 * Implements hook_menu().
 */
function commerce_bpc_menu() {

  // Add a product.
  $items['admin/commerce/products/add-bulk'] = array(
    'title' => 'Bulk add products',
    'description' => 'Add a new group of products for sale in bulk.',
    'page callback' => 'commerce_bpc_add_page',
    'access callback' => 'commerce_bpc_product_add_any_access',
    'file' => 'commerce_bpc.pages.inc',
  );
  foreach (commerce_product_types() as $type => $product_type) {
    if (commerce_bpc_valid_product_type($type)) {
      $items['admin/commerce/products/add-bulk/' . $type] = array(
        'title' => 'Bulk add @name',
        'title arguments' => array('@name' => $product_type['name']),
        'description' => $product_type['description'],
        'page callback' => 'drupal_get_form',
        'page arguments' => array('commerce_bpc_create_bulk_form', $type),
        'file' => 'commerce_bpc.forms.inc',
        'access callback' => 'commerce_product_access',
        'access arguments' => array('create', $type),
      );
    }
  }
  return $items;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function commerce_bpc_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action link 'admin/commerce/products/add-bulk' on 'admin/commerce/products'.
  if ($root_path == 'admin/commerce/products') {
    $item = menu_get_item('admin/commerce/products/add-bulk');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}
/**
 * Implements hook_field_create_instance().
 *
 * Rebuilds the menu so that new menu items are created under
 * /admin/commerce/add-bulk if the product type is now
 * available for bulk creation.
 */
function commerce_bpc_field_create_instance($instance) {
  if ($instance['entity_type'] == 'commerce_product'
  // Only rebuild the menu if the product type is saved
  // already---for else, the menu gets screwed up.
    && array_key_exists($instance['bundle'], commerce_product_types())) {
    menu_rebuild();
  }
}
/**
 * Implements hook_field_delete_instance().
 *
 * Rebuilds the  menu so that the menu item under /admin/commerce/add-bulk is
 * removed if the product type is no longer available for bulk creation.
 */
function commerce_bpc_field_delete_instance($instance) {
  if ($instance['entity_type'] == 'commerce_product') {
    menu_rebuild();
  }
}
/**
 * Implements of hook_form_alter().
 */
function commerce_bpc_form_alter(&$form, &$form_state, $form_id) {
  if (isset($_GET['bulk_product_ids']) AND isset($_SESSION['bulk_product_ids'][$_GET['bulk_product_ids']])) {
    $ids = $_SESSION['bulk_product_ids'][$_GET['bulk_product_ids']];
    if ($fields = field_info_instances('node', $form['type']['#value'])) {
      // Get the field name of the product_reference field
      foreach ($fields as $name => $field) {
        $field_info = field_read_field($name);
        // Make sure field is of the commerce_product_reference type
        if ($field_info['type'] == 'commerce_product_reference') {
          // Do something different depending on the field type
          switch ($form[$field['field_name']][LANGUAGE_NONE]['#type']) {
            case 'textfield':
              $form[$field['field_name']][LANGUAGE_NONE]['#default_value'] = implode(', ', $ids);
            break;

            case 'select':
            case 'checkboxes':
              $form[$field['field_name']][LANGUAGE_NONE]['#default_value'] = array_keys($ids);
            break;
          }
        }
      }
    }
  }
}


// ======================================
// API Functions
// ======================================

/**
 * API function to create bulk products based on the given parameters
 *
 * @param $product_type
 *   Which product type the newly created products will belong to
 * @param $options
 *   This array contains the options that were selected for each group. It should take the following form:
 *   $options = array(
 *      'group1' => array(
 *          'option1' => 'option1',
 *          'option2' => 'option2',
 *        ),
 *      'group2' => array(
 *          'option1' => 'option1',
 *          'option2' => 'option2',
 *        ),
 *    );
 *  This is the format in which list.module delivers its values in $form_state.
 * @param $commerce_price
 *   The base price for each product, an array with the following form:
 *   $commerce_price = array(
 *      [price] => 3.21,
 *      [currency_code] => USD
 *      );
 * @param $status
 *   The status for each newly created product
 * @param $sku_pattern
 *   The pattern (with relevant tokens) to be used for generating the SKU for each newly created product
 * @param $title_pattern
 *   The pattern (with relevant tokens) to be used for generating the Title for each newly created product
 * @param $uid
 *   The user id to associate with the products. Defaults to 1
 *
 * @return
 *   An array of the new products that were created
 */
function commerce_bpc_create_bulk_products($product_type, $options, $commerce_price, $status, $sku_pattern, $title_pattern, $uid = 1) {
  $bulk_products = array();

  // Get all of the possible combinations
  $combinations = commerce_bpc_get_combinations($options);

  // For each combination, create a product
  foreach ($combinations as $combination) {
    $bulk_products[] = commerce_bpc_create_product($product_type, $combination, $commerce_price, $status, $sku_pattern, $title_pattern, $uid);
  }

  return $bulk_products;
}

/**
 * API function to create a product based on the given parameters
 *
 * @param $product_type
 *   Which product type the newly created products will belong to
 * @param $combination
 *   An array containing the field values for this product. It should take the following form:
 *   $options = array(
 *      'field_1' => array(
 *          'value' => 'value1',
 *          'name' => 'name1', (Optional)
 *        ),
 *      'field_2' => array(
 *          'value' => 'value2',
 *          'name' => 'name2', (Optional)
 *        ),
 *    );
 * @param $commerce_price
 *   The base price for each product, an array with the following form:
 *   $commerce_price = array(
 *      [price] => 3.21,
 *      [currency_code] => USD
 *      );
 * @param $status
 *   The status for each newly created product
 * @param $sku_pattern
 *   The pattern (with relevant tokens) to be used for generating the SKU for each newly created product
 * @param $title_pattern
 *   The pattern (with relevant tokens) to be used for generating the Title for each newly created product
 * @param $uid
 *   The user id to associate with the products. Defaults to 1
 *
 * @return
 *   An array of the new products that were created
 */
function commerce_bpc_create_product($product_type, $combination, $commerce_price, $status, $sku_pattern, $title_pattern, $uid) {
  $form_state = array();
  $form = array();
  $form['#parents'] = array();

  $commerce_price_path = array();
  $commerce_price_path[LANGUAGE_NONE][0] = $commerce_price;

  // Generate a new product object
  $new_product = commerce_product_new($product_type);

  $new_product->status = $status;
  $new_product->commerce_price = $commerce_price_path;
  $new_product->uid = $uid;

  // Replace the tokens for the SKU and Title
  $replacements = array('bulk_product' => commerce_bpc_build_replacement_tokens($combination));
  $new_product->sku = token_replace($sku_pattern, $replacements);
  $new_product->title = token_replace($title_pattern, $replacements);

  // Set the proper values in the form_state for this product's combination of fields
  foreach ($combination as $field => $field_info) {
    $path = array();

    $path[LANGUAGE_NONE][0]['value'] = $field_info['value'];
    $form_state['values'][$field] = $path;
  }
  // Notify field widgets to save their field data
  field_attach_submit('commerce_product', $new_product, $form, $form_state);

  return commerce_product_save($new_product);
}

/**
 * Wrapper for commerce_bpc_iterate_options which returns the possible combinations of an array of options
 *
 * @param $options
 *   This array contains the options that were selected for each group. It should take the following form:
 *   $options = array(
 *      'group1' => array(
 *          'option1' => 'option1',
 *          'option2' => 'option2',
 *        ),
 *      'group2' => array(
 *          'option1' => 'option1',
 *          'option2' => 'option2',
 *        ),
 *    );
 * @return
 *   This function returns an array of all the possible combinations of the $options in the following format:
 *   $combinations = array(
 *     '0' => array(
 *             'field1' => array(
 *                           'value' => 'value1',
 *                           'name'  => 'name1',
 *                         ),
 *             'field2' => array(
 *                           'value' => 'value1',
 *                           'name'  => 'name1',
 *                         ),
 *            ),
 *     '1' => array(
 *             'field1' => array(
 *                           'value' => 'value1',
 *                           'name'  => 'name1',
 *                         ),
 *             'field2' => array(
 *                           'value' => 'value2',
 *                           'name'  => 'name2',
 *                         ),
 *            ),
 *     '2' => array(
 *             'field1' => array(
 *                           'value' => 'value2',
 *                           'name'  => 'name2',
 *                         ),
 *             'field2' => array(
 *                           'value' => 'value1',
 *                           'name'  => 'name1',
 *                         ),
 *            ),
 *     '3' => array(
 *             'field1' => array(
 *                           'value' => 'value2',
 *                           'name'  => 'name2',
 *                         ),
 *             'field2' => array(
 *                           'value' => 'value2',
 *                           'name'  => 'name2',
 *                         ),
 *            ),
 *     );
 */
function commerce_bpc_get_combinations($options) {
  // We need the cartesian product of the arrays in $options.
  // In order to do that, we loop through these arrays, at every
  // stage taking the cartesian product of the actual array with
  // what is there already. So after the first iteration,
  // $combinations will just be the first member of $options.
  // After the second, it will be the product of this with the
  // second member, after the third, we will have the product
  // of the previous product with the third member, and so on.

  // Initialize with an empty array as sole member, so that the first
  // iteration has something to work with
  $combinations = array(array());
  foreach ($options as $field_name => $field_values) {
    $field_info = field_info_field($field_name);
    switch ($field_info['module']) {
      case 'list':
        $combinations = commerce_bpc_commerce_bpc_list_get_combinations($combinations, $field_name, $field_values);
        break;
      case 'text':
        $combinations = commerce_bpc_commerce_bpc_text_get_combinations($combinations, $field_name,
            $field_values);
      break;
    }
  }
  return $combinations;
}

/**
 * Check if a product_type is a valid candidate for Bulk Product Creation
 */
function commerce_bpc_valid_product_type($type) {
  // Load the fields available to the product type
  $fields = field_info_instances('commerce_product', $type);

  foreach ($fields as $field_type => $field) {
    if ($field_type != 'commerce_price' AND commerce_bpc_valid_field($field)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Determine whether the field can be used with Bulk Product Creation
 */
function commerce_bpc_valid_field($field) {
  //drupal_set_message('Field Valid Check: <pre>'. print_r($field, TRUE) .'</pre>');
  $field_info = field_info_field($field['field_name']);

  switch ($field_info['module']) {
    case 'list':
    case 'text':
      return TRUE;
    break;

    default:

    break;
  }
  return FALSE;
}

/**
 * Helper function to return an array of available node types for bulk product attachment
 */
function commerce_bpc_get_node_types($product_type) {
  $allowed_types = array();
  $node_types = node_type_get_types();

  // Filter this so that only node types that have the Product Reference field are used
  foreach ($node_types as $type => $node_type) {
    $fields = field_info_instances('node', $type);

    foreach ($fields as $name => $field) {
      $field_info = field_info_field($name);
      // Make sure the selected product is acceptable to the product reference field
      if ($field_info['module'] == 'commerce_product_reference' AND ($field['settings']['referenceable_types'][$product_type] OR empty($field['settings']['referenceable_types']))) {
        // drupal_set_message('Field Info: <pre>'. print_r($field_info, TRUE) .'</pre>');
        // Possible FIXME - Make sure the field can accept multiple values
        $allowed_types[$type] = $node_type->name;
        break;
      }
    }
  }

  return $allowed_types;
}
/**
 * Create combinations for a list field.
 *
 * Given a set of existing combinations, and a set of values for
 * a list field, return a new set of combinations resulting from
 * combining the values of the list field with all combinations.
 *
 * This will become a hook implementation soon, for now it is
 * called directly.
 *
 * @param $old_combinations
 *   An array of combinations that have been generated so far.
 * @param $field_name
 *   The name of the field for which values are to be added.
 * @param $values
 *   The values for which combinations are to be created.
 *
 * @return An array resulting of combining each element of $old_combinations
 *         with each element of $values.
 */
function commerce_bpc_commerce_bpc_list_get_combinations($old_combinations, $field_name, $values) {
  $combinations = array();
  $field_info = field_info_field($field_name);
  foreach ($old_combinations as $combination) {
    foreach ($values as $key => $val) {
      if ($val !== NULL) {
        $combinations[] = $combination + array(
          $field_name => array(
            'value' => $val,
            'name' => $field_info['settings']['allowed_values'][$val],
          ),
        );
      }
    }
  }
  return $combinations;
}
/**
 * Create combinations for a text field.
 *
 * Given a set of existing combinations, and a value for a text field,
 * return a new set of combinations resulting from
 * combining the values of the list field with all combinations.
 *
 * This will become a hook implementation soon, for now it is
 * called directly.
 *
 * @param $old_combinations
 *   An array of combinations that have been generated so far.
 * @param $field_name
 *   The name of the field for which values are to be added.
 * @param $values
 *   The values for which combinations are to be created.
 *
 * @return An array resulting of combining each element of $old_combinations
 *         with each element of $values.
 */
function commerce_bpc_commerce_bpc_text_get_combinations($old_combinations, $field_name, $values) {
  $combinations = array();
  foreach ($old_combinations as $combination) {
    $combinations[] = $combination + array($field_name => $values);
  }
  return $combinations;
}
/**
 * Access callback: determines if there is any bulk-able product type that
 * the user is allowed to create.
 */
function commerce_bpc_product_add_any_access() {
  // Grant automatic access to users with administer products permission.
  if (user_access('administer products')) {
    return TRUE;
  }

  // Check the user's access on a product type basis.
  foreach (commerce_product_types() as $type => $product_type) {
    if (commerce_product_access('create', $type) && commerce_bpc_valid_product_type($type)) {
      return TRUE;
    }
  }

  return FALSE;
}